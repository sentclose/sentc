/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export interface SignHead {
  id: string
  alg: string
}
export interface EncryptedHead {
  id: string
  sign?: SignHead
}
export interface CryptoRawOutput {
  head: string
  data: Buffer
}
export declare function splitHeadAndEncryptedData(data: Buffer): EncryptedHead
export declare function splitHeadAndEncryptedString(data: string): EncryptedHead
export declare function deserializeHeadFromString(head: string): EncryptedHead
export declare function encryptRawSymmetric(key: string, data: Buffer, signKey?: string | undefined | null): CryptoRawOutput
export declare function decryptRawSymmetric(key: string, encryptedData: Buffer, head: string, verifyKeyData?: string | undefined | null): Buffer
export declare function encryptSymmetric(key: string, data: Buffer, signKey?: string | undefined | null): Buffer
export declare function decryptSymmetric(key: string, encryptedData: Buffer, verifyKeyData?: string | undefined | null): Buffer
export declare function encryptStringSymmetric(key: string, data: string, signKey?: string | undefined | null): string
export declare function decryptStringSymmetric(key: string, encryptedData: string, verifyKeyData?: string | undefined | null): string
export declare function encryptRawAsymmetric(replyPublicKeyData: string, data: Buffer, signKey?: string | undefined | null): CryptoRawOutput
export declare function decryptRawAsymmetric(privateKey: string, encryptedData: Buffer, head: string, verifyKeyData?: string | undefined | null): Buffer
export declare function encryptAsymmetric(replyPublicKeyData: string, data: Buffer, signKey?: string | undefined | null): Buffer
export declare function decryptAsymmetric(privateKey: string, encryptedData: Buffer, verifyKeyData?: string | undefined | null): Buffer
export declare function encryptStringAsymmetric(replyPublicKeyData: string, data: string, signKey?: string | undefined | null): string
export declare function decryptStringAsymmetric(privateKey: string, encryptedData: string, verifyKeyData?: string | undefined | null): string
export interface NonRegisteredKeyOutput {
  key: string
  encryptedKey: string
}
export declare function generateNonRegisterSymKey(masterKey: string): NonRegisteredKeyOutput
export declare function generateNonRegisterSymKeyByPublicKey(replyPublicKey: string): NonRegisteredKeyOutput
export declare function decryptSymKey(masterKey: string, encryptedSymmetricKeyInfo: string): string
export declare function decryptSymKeyByPrivateKey(privateKey: string, encryptedSymmetricKeyInfo: string): string
export declare function doneFetchSymKey(masterKey: string, serverOut: string, nonRegistered: boolean): string
export declare function doneFetchSymKeyByPrivateKey(privateKey: string, serverOut: string, nonRegistered: boolean): string
export interface SearchableCreateOutput {
  hashes: Array<string>
  alg: string
  keyId: string
}
export declare function createSearchableRaw(key: string, data: string, full: boolean, limit?: number | undefined | null): Array<string>
export declare function createSearchable(key: string, data: string, full: boolean, limit?: number | undefined | null): SearchableCreateOutput
export declare function search(key: string, data: string): string
export interface SortableEncryptOutput {
  number: number
  alg: string
  keyId: string
}
export declare function sortableEncryptRawNumber(key: string, data: number): number
export declare function sortableEncryptNumber(key: string, data: number): SortableEncryptOutput
export declare function sortableEncryptRawString(key: string, data: string): number
export declare function sortableEncryptString(key: string, data: string): SortableEncryptOutput
export const enum BelongsToType {
  Group = 0,
  User = 1,
  None = 2
}
export interface FilePartListItem {
  partId: string
  sequence: number
  externStorage: boolean
}
export interface FileData {
  fileId: string
  masterKeyId: string
  owner: string
  belongsTo?: string
  belongsToType: BelongsToType
  encryptedKey: string
  encryptedKeyAlg: string
  encryptedFileName?: string
  partList: Array<FilePartListItem>
}
export declare function fileDownloadFileMeta(baseUrl: string, authToken: string, jwt: string | undefined | null, id: string, groupId?: string | undefined | null, groupAsMember?: string | undefined | null): Promise<FileData>
export interface FileDownloadResult {
  nextFileKey: string
  file: Buffer
}
export declare function fileDownloadAndDecryptFilePartStart(baseUrl: string, urlPrefix: string | undefined | null, authToken: string, partId: string, contentKey: string, verifyKeyData?: string | undefined | null): Promise<FileDownloadResult>
export declare function fileDownloadAndDecryptFilePart(baseUrl: string, urlPrefix: string | undefined | null, authToken: string, partId: string, contentKey: string, verifyKeyData?: string | undefined | null): Promise<FileDownloadResult>
export declare function fileDownloadPartList(baseUrl: string, authToken: string, fileId: string, lastSequence: string): Promise<Array<FilePartListItem>>
export interface FileRegisterOutput {
  fileId: string
  sessionId: string
  encryptedFileName?: string
}
export interface FilePrepareRegister {
  encryptedFileName?: string
  serverInput: string
}
export interface FileDoneRegister {
  fileId: string
  sessionId: string
}
export declare function fileRegisterFile(baseUrl: string, authToken: string, jwt: string, masterKeyId: string, contentKey: string, encryptedContentKey: string, belongsToId: string | undefined | null, belongsToType: string, fileName?: string | undefined | null, groupId?: string | undefined | null, groupAsMember?: string | undefined | null): Promise<FileRegisterOutput>
export declare function filePrepareRegisterFile(masterKeyId: string, contentKey: string, encryptedContentKey: string, belongsToId: string | undefined | null, belongsToType: string, fileName?: string | undefined | null): FilePrepareRegister
export declare function fileDoneRegisterFile(serverOutput: string): FileDoneRegister
export declare function fileUploadPartStart(baseUrl: string, urlPrefix: string | undefined | null, authToken: string, jwt: string, sessionId: string, end: boolean, sequence: number, contentKey: string, signKey: string | undefined | null, part: Buffer): Promise<string>
export declare function fileUploadPart(baseUrl: string, urlPrefix: string | undefined | null, authToken: string, jwt: string, sessionId: string, end: boolean, sequence: number, contentKey: string, signKey: string | undefined | null, part: Buffer): Promise<string>
export declare function fileFileNameUpdate(baseUrl: string, authToken: string, jwt: string, fileId: string, contentKey: string, fileName?: string | undefined | null): Promise<void>
export declare function fileDeleteFile(baseUrl: string, authToken: string, jwt: string, fileId: string, groupId?: string | undefined | null, groupAsMember?: string | undefined | null): Promise<void>
export interface GroupKeyData {
  privateGroupKey: string
  publicGroupKey: string
  exportedPublicKey: string
  groupKey: string
  time: string
  groupKeyId: string
}
export interface GroupOutDataKeys {
  privateKeyId: string
  keyData: string
  signedByUserId?: string
  signedByUserSignKeyId?: string
}
export interface GroupOutDataHmacKeys {
  groupKeyId: string
  keyData: string
}
export interface GroupOutDataSortableKeys {
  groupKeyId: string
  keyData: string
}
export interface GroupOutData {
  groupId: string
  parentGroupId?: string
  rank: number
  keyUpdate: boolean
  createdTime: string
  joinedTime: string
  keys: Array<GroupOutDataKeys>
  hmacKeys: Array<GroupOutDataHmacKeys>
  sortableKeys: Array<GroupOutDataSortableKeys>
  accessByGroupAsMember?: string
  accessByParentGroup?: string
  isConnectedGroup: boolean
}
export interface GroupInviteReqList {
  groupId: string
  time: string
}
export interface KeyRotationInput {
  error?: string
  encryptedEphemeralKeyByGroupKeyAndPublicKey: string
  encryptedGroupKeyByEphemeral: string
  ephemeralAlg: string
  encryptedEphKeyKeyId: string
  previousGroupKeyId: string
  time: string
  newGroupKeyId: string
}
/**
Create input for the server api.

Use this for a group and child group. For child group use the public key of the parent group!
*/
export declare function groupPrepareCreateGroup(creatorsPublicKey: string, signKey: string | undefined | null, starter: string): string
/**
Create a group with a request.

Only the default values are sent to the server, no extra data. If extra data is required, use prepare_create
*/
export declare function groupCreateGroup(baseUrl: string, authToken: string, jwt: string, creatorsPublicKey: string, groupAsMember: string | undefined | null, signKey: string | undefined | null, starter: string): Promise<string>
export declare function groupCreateChildGroup(baseUrl: string, authToken: string, jwt: string, parentPublicKey: string, parentId: string, adminRank: number, groupAsMember: string | undefined | null, signKey: string | undefined | null, starter: string): Promise<string>
export declare function groupCreateConnectedGroup(baseUrl: string, authToken: string, jwt: string, connectedGroupId: string, adminRank: number, parentPublicKey: string, groupAsMember: string | undefined | null, signKey: string | undefined | null, starter: string): Promise<string>
/**
Get the group data without a request.

Use the parent group private key when fetching child group data.
*/
export declare function groupExtractGroupData(serverOutput: string): GroupOutData
/**
Get keys from pagination.

Call the group route with the last fetched key time and the last fetched key id. Get both from the key data.
*/
export declare function groupExtractGroupKeys(serverOutput: string): Array<GroupOutDataKeys>
export declare function groupGetGroupData(baseUrl: string, authToken: string, jwt: string, id: string, groupAsMember?: string | undefined | null): Promise<GroupOutData>
export declare function groupGetGroupKeys(baseUrl: string, authToken: string, jwt: string, id: string, lastFetchedTime: string, lastFetchedKeyId: string, groupAsMember?: string | undefined | null): Promise<Array<GroupOutDataKeys>>
export declare function groupGetGroupKey(baseUrl: string, authToken: string, jwt: string, id: string, keyId: string, groupAsMember?: string | undefined | null): Promise<GroupOutDataKeys>
export declare function groupDecryptKey(privateKey: string, serverKeyData: string, verifyKey?: string | undefined | null): GroupKeyData
export declare function groupDecryptHmacKey(groupKey: string, serverKeyData: string): string
export declare function groupDecryptSortableKey(groupKey: string, serverKeyData: string): string
export interface GroupUserListItem {
  userId: string
  rank: number
  joinedTime: string
  userType: number
}
export interface GroupDataCheckUpdateServerOutput {
  keyUpdate: boolean
  rank: number
}
export interface GroupChildrenList {
  groupId: string
  time: string
  parent?: string
}
export interface ListGroups {
  groupId: string
  time: string
  joinedTime: string
  rank: number
  parent?: string
}
export declare function groupGetMember(baseUrl: string, authToken: string, jwt: string, id: string, lastFetchedTime: string, lastFetchedId: string, groupAsMember?: string | undefined | null): Promise<Array<GroupUserListItem>>
export declare function groupGetGroupUpdates(baseUrl: string, authToken: string, jwt: string, id: string, groupAsMember?: string | undefined | null): Promise<GroupDataCheckUpdateServerOutput>
export declare function groupGetAllFirstLevelChildren(baseUrl: string, authToken: string, jwt: string, id: string, lastFetchedTime: string, lastFetchedGroupId: string, groupAsMember?: string | undefined | null): Promise<Array<GroupChildrenList>>
export declare function groupGetGroupsForUser(baseUrl: string, authToken: string, jwt: string, lastFetchedTime: string, lastFetchedGroupId: string, groupId?: string | undefined | null): Promise<Array<ListGroups>>
/**
Prepare all group keys for a new member.

Use the group keys from get group data or get group keys fn as a string array
*/
export declare function groupPrepareKeysForNewMember(userPublicKey: string, groupKeys: string, keyCount: number, rank: number | undefined | null, adminRank: number): string
export declare function groupInviteUser(baseUrl: string, authToken: string, jwt: string, id: string, userId: string, keyCount: number, rank: number | undefined | null, adminRank: number, autoInvite: boolean, groupInvite: boolean, reInvite: boolean, userPublicKey: string, groupKeys: string, groupAsMember?: string | undefined | null): Promise<string>
export declare function groupInviteUserSession(baseUrl: string, authToken: string, jwt: string, id: string, autoInvite: boolean, sessionId: string, userPublicKey: string, groupKeys: string, groupAsMember?: string | undefined | null): Promise<void>
export declare function groupGetInvitesForUser(baseUrl: string, authToken: string, jwt: string, lastFetchedTime: string, lastFetchedGroupId: string, groupId?: string | undefined | null, groupAsMember?: string | undefined | null): Promise<Array<GroupInviteReqList>>
export declare function groupAcceptInvite(baseUrl: string, authToken: string, jwt: string, id: string, groupId?: string | undefined | null, groupAsMember?: string | undefined | null): Promise<void>
export declare function groupRejectInvite(baseUrl: string, authToken: string, jwt: string, id: string, groupId?: string | undefined | null, groupAsMember?: string | undefined | null): Promise<void>
export interface GroupJoinReqList {
  userId: string
  time: string
  userType: number
}
export declare function groupGetSentJoinReqUser(baseUrl: string, authToken: string, jwt: string, lastFetchedTime: string, lastFetchedGroupId: string, groupAsMember?: string | undefined | null): Promise<Array<GroupInviteReqList>>
export declare function groupGetSentJoinReq(baseUrl: string, authToken: string, jwt: string, id: string, adminRank: number, lastFetchedTime: string, lastFetchedGroupId: string, groupAsMember?: string | undefined | null): Promise<Array<GroupInviteReqList>>
export declare function groupDeleteSentJoinReqUser(baseUrl: string, authToken: string, jwt: string, joinReqGroupId: string, groupAsMember?: string | undefined | null): Promise<void>
export declare function groupDeleteSentJoinReq(baseUrl: string, authToken: string, jwt: string, id: string, adminRank: number, joinReqGroupId: string, groupAsMember?: string | undefined | null): Promise<void>
export declare function groupJoinReq(baseUrl: string, authToken: string, jwt: string, id: string, groupId: string, groupAsMember?: string | undefined | null): Promise<void>
export declare function groupGetJoinReqs(baseUrl: string, authToken: string, jwt: string, id: string, adminRank: number, lastFetchedTime: string, lastFetchedId: string, groupAsMember?: string | undefined | null): Promise<Array<GroupJoinReqList>>
export declare function groupRejectJoinReq(baseUrl: string, authToken: string, jwt: string, id: string, adminRank: number, rejectedUserId: string, groupAsMember?: string | undefined | null): Promise<void>
export declare function groupAcceptJoinReq(baseUrl: string, authToken: string, jwt: string, id: string, userId: string, keyCount: number, rank: number | undefined | null, adminRank: number, userPublicKey: string, groupKeys: string, groupAsMember?: string | undefined | null): Promise<string>
export declare function groupJoinUserSession(baseUrl: string, authToken: string, jwt: string, id: string, sessionId: string, userPublicKey: string, groupKeys: string, groupAsMember?: string | undefined | null): Promise<void>
export declare function groupStopGroupInvites(baseUrl: string, authToken: string, jwt: string, id: string, adminRank: number, groupAsMember?: string | undefined | null): Promise<void>
export declare function leaveGroup(baseUrl: string, authToken: string, jwt: string, id: string, groupAsMember?: string | undefined | null): Promise<void>
export declare function groupPrepareKeyRotation(preGroupKey: string, publicKey: string, signKey: string | undefined | null, starter: string): string
export declare function groupDoneKeyRotation(privateKey: string, publicKey: string, preGroupKey: string, serverOutput: string): string
export declare function groupKeyRotation(baseUrl: string, authToken: string, jwt: string, id: string, publicKey: string, preGroupKey: string, signKey: string | undefined | null, starter: string, groupAsMember?: string | undefined | null): Promise<string>
export declare function groupPreDoneKeyRotation(baseUrl: string, authToken: string, jwt: string, id: string, groupAsMember?: string | undefined | null): Promise<Array<KeyRotationGetOut>>
export declare function groupGetDoneKeyRotationServerInput(serverOutput: string): KeyRotationInput
export declare function groupFinishKeyRotation(baseUrl: string, authToken: string, jwt: string, id: string, serverOutput: string, preGroupKey: string, publicKey: string, privateKey: string, groupAsMember?: string | undefined | null): Promise<void>
export declare function groupPrepareUpdateRank(userId: string, rank: number, adminRank: number): string
export declare function groupUpdateRank(baseUrl: string, authToken: string, jwt: string, id: string, userId: string, rank: number, adminRank: number, groupAsMember?: string | undefined | null): Promise<void>
export declare function groupKickUser(baseUrl: string, authToken: string, jwt: string, id: string, userId: string, adminRank: number, groupAsMember?: string | undefined | null): Promise<void>
export declare function groupDeleteGroup(baseUrl: string, authToken: string, jwt: string, id: string, adminRank: number, groupAsMember?: string | undefined | null): Promise<void>
export interface GroupPublicKeyData {
  publicKey: string
  publicKeyId: string
}
export declare function groupGetPublicKeyData(baseUrl: string, authToken: string, id: string): Promise<GroupPublicKeyData>
export interface Claims {
  aud: string
  sub: string
  exp: number
  iat: number
  fresh: boolean
}
export declare function decodeJwt(jwt: string): Claims
export interface GeneratedRegisterData {
  identifier: string
  password: string
}
export interface DeviceKeyData {
  privateKey: string
  publicKey: string
  signKey: string
  verifyKey: string
  exportedPublicKey: string
  exportedVerifyKey: string
}
export interface UserKeyData {
  privateKey: string
  publicKey: string
  groupKey: string
  time: string
  groupKeyId: string
  signKey: string
  verifyKey: string
  exportedPublicKey: string
  exportedPublicKeySigKeyId?: string
  exportedVerifyKey: string
}
export interface PrepareLoginOtpOutput {
  masterKey: string
  authKey: string
}
export interface UserLoginOut {
  userData?: UserData
  mfa?: PrepareLoginOtpOutput
}
export interface UserData {
  jwt: string
  userId: string
  deviceId: string
  refreshToken: string
  keys: DeviceKeyData
  userKeys: Array<UserKeyData>
  hmacKeys: Array<GroupOutDataHmacKeys>
}
/**
# Check if the identifier is available for this app
*/
export declare function checkUserIdentifierAvailable(baseUrl: string, authToken: string, userIdentifier: string): Promise<boolean>
/**
# Check if the identifier is available

but without making a request
*/
export declare function prepareCheckUserIdentifierAvailable(userIdentifier: string): string
/**
# Validates the response if the identifier is available

but without making a request
*/
export declare function doneCheckUserIdentifierAvailable(serverOutput: string): boolean
/**
Generates identifier and password for a user or device
 */
export declare function generateUserRegisterData(): GeneratedRegisterData
/**
# Get the user input from the user client

This is used when the register endpoint should only be called from the backend and not the clients.

For full-register see register()
*/
export declare function prepareRegister(userIdentifier: string, password: string): string
/**
# Validates the response of register

Returns the new user id
*/
export declare function doneRegister(serverOutput: string): string
/**
# Register a new user for the app

Do the full req incl. req.
No checking about spamming and just return the user id.
*/
export declare function register(baseUrl: string, authToken: string, userIdentifier: string, password: string): Promise<string>
export declare function prepareRegisterDeviceStart(deviceIdentifier: string, password: string): string
export declare function doneRegisterDeviceStart(serverOutput: string): void
export declare function registerDeviceStart(baseUrl: string, authToken: string, deviceIdentifier: string, password: string): Promise<string>
export interface PreRegisterDeviceData {
  input: string
  exportedPublicKey: string
}
export interface RegisterDeviceData {
  sessionId: string
  exportedPublicKey: string
}
export declare function prepareRegisterDevice(serverOutput: string, userKeys: string, keyCount: number): PreRegisterDeviceData
export declare function registerDevice(baseUrl: string, authToken: string, jwt: string, serverOutput: string, keyCount: number, userKeys: string): Promise<RegisterDeviceData>
export declare function userDeviceKeySessionUpload(baseUrl: string, authToken: string, jwt: string, sessionId: string, userPublicKey: string, groupKeys: string): Promise<void>
/**
# Log in the user to this app

Does the login requests. 1. for auth, 2nd to get the keys.

If there is more data in the backend, then it is possible to call it via the jwt what is returned by the done login request.

The other backend can validate the jwt
*/
export declare function login(baseUrl: string, authToken: string, userIdentifier: string, password: string): Promise<UserLoginOut>
export declare function mfaLogin(baseUrl: string, authToken: string, masterKeyEncryption: string, authKey: string, userIdentifier: string, token: string, recovery: boolean): Promise<UserData>
export declare function doneFetchUserKey(privateKey: string, serverOutput: string): UserKeyData
export declare function fetchUserKey(baseUrl: string, authToken: string, jwt: string, keyId: string, privateKey: string): Promise<UserKeyData>
export declare function getFreshJwt(baseUrl: string, authToken: string, userIdentifier: string, password: string, mfaToken?: string | undefined | null, mfaRecovery?: boolean | undefined | null): Promise<string>
export interface UserInitServerOutput {
  jwt: string
  invites: Array<GroupInviteReqList>
}
export declare function refreshJwt(baseUrl: string, authToken: string, jwt: string, refreshToken: string): Promise<string>
export declare function initUser(baseUrl: string, authToken: string, jwt: string, refreshToken: string): Promise<UserInitServerOutput>
export declare function userCreateSafetyNumber(verifyKey1: string, userId1: string, verifyKey2?: string | undefined | null, userId2?: string | undefined | null): string
export declare function userVerifyUserPublicKey(verifyKey: string, publicKey: string): boolean
export interface UserDeviceList {
  deviceId: string
  time: string
  deviceIdentifier: string
}
export declare function getUserDevices(baseUrl: string, authToken: string, jwt: string, lastFetchedTime: string, lastFetchedId: string): Promise<Array<UserDeviceList>>
export declare function resetPassword(baseUrl: string, authToken: string, jwt: string, newPassword: string, decryptedPrivateKey: string, decryptedSignKey: string): Promise<void>
export declare function changePassword(baseUrl: string, authToken: string, userIdentifier: string, oldPassword: string, newPassword: string, mfaToken?: string | undefined | null, mfaRecovery?: boolean | undefined | null): Promise<void>
export declare function deleteUser(baseUrl: string, authToken: string, freshJwt: string): Promise<void>
export declare function deleteDevice(baseUrl: string, authToken: string, freshJwt: string, deviceId: string): Promise<void>
export declare function updateUser(baseUrl: string, authToken: string, jwt: string, userIdentifier: string): Promise<void>
export interface UserPublicKeyData {
  publicKey: string
  publicKeyId: string
  publicKeySigKeyId?: string
}
export declare function userFetchPublicKey(baseUrl: string, authToken: string, userId: string): Promise<UserPublicKeyData>
export declare function userFetchVerifyKey(baseUrl: string, authToken: string, userId: string, verifyKeyId: string): Promise<string>
export interface KeyRotationGetOut {
  preGroupKeyId: string
  newGroupKeyId: string
  encryptedEphKeyKeyId: string
  serverOutput: string
}
export declare function userKeyRotation(baseUrl: string, authToken: string, jwt: string, publicDeviceKey: string, preUserKey: string): Promise<string>
export declare function userPreDoneKeyRotation(baseUrl: string, authToken: string, jwt: string): Promise<Array<KeyRotationGetOut>>
export declare function userGetDoneKeyRotationServerInput(serverOutput: string): KeyRotationInput
export declare function userFinishKeyRotation(baseUrl: string, authToken: string, jwt: string, serverOutput: string, preGroupKey: string, publicKey: string, privateKey: string): Promise<void>
export interface OtpRegister {
  secret: string
  alg: string
  recover: Array<string>
}
export interface OtpRegisterUrl {
  url: string
  recover: Array<string>
}
export interface OtpRecoveryKeysOutput {
  keys: Array<string>
}
export declare function registerRawOtp(baseUrl: string, authToken: string, jwt: string): Promise<OtpRegister>
export declare function registerOtp(baseUrl: string, authToken: string, jwt: string, issuer: string, audience: string): Promise<OtpRegisterUrl>
export declare function getOtpRecoverKeys(baseUrl: string, authToken: string, jwt: string): Promise<OtpRecoveryKeysOutput>
export declare function resetRawOtp(baseUrl: string, authToken: string, jwt: string): Promise<OtpRegister>
export declare function resetOtp(baseUrl: string, authToken: string, jwt: string, issuer: string, audience: string): Promise<OtpRegisterUrl>
export declare function disableOtp(baseUrl: string, authToken: string, jwt: string): Promise<void>
